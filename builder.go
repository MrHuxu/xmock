package main

import (
	"bytes"
	"go/format"
	"html/template"
	"io"
)

const (
	templateStr = `
	// Code generated by MrHuxu/xmock. DO NOT EDIT.

	package {{ .OutPkg }}
	
	{{ if len .FileItem.ImportItems }}
	import (
		{{ range $i, $import := .FileItem.ImportItems }}
		{{ $import.Name }} "{{ $import.Path }}"{{ end }}
	)
	{{ end }}
	
	{{ $fileItem := .FileItem }}

	{{ range $i, $interface := .FileItem.InterfaceItems }}
	// {{ $interface.Name }} mocks the implementation of interface {{ $fileItem.File }}:{{ $interface.Name }}
	type {{ $interface.Name }} struct {
		{{ range $j, $method := $interface.Methods }}
		Mock{{ $method.Name }} func({{ $method.ParamListAsCallee }}) ({{$method.ResultList}}) // Mock{{ $method.Name }} mocks the method {{ $interface.Name }}#{{ $method.Name }}{{ end }}
	}
	
	{{ range $j, $method := $interface.Methods }}
	// {{ $method.Name }} ...
	func ({{ $interface.ShorttenName }} *{{ $interface.Name }}) {{ $method.Name }} ({{ $method.ParamListAsCallee }}) ({{$method.ResultList}}) {
		{{ if len $method.ResultList }}return{{ end }} {{ $interface.ShorttenName }}.Mock{{ $method.Name }}({{ $method.ParamListAsCaller }})
	}
	{{ end }}
	{{ end }}
	`
)

var (
	tmpl = template.Must(template.New("dist").Parse(templateStr))
)

type buildArgs struct {
	OutPkg   string
	FileItem *FileItem
}

func buildDistFile(fileItem *FileItem) io.Reader {
	var tmp bytes.Buffer
	if err := tmpl.Execute(&tmp, buildArgs{
		OutPkg:   flagOutPkg,
		FileItem: fileItem,
	}); err != nil {
		logger.Fatalf("_fatal||reason=%+v", err)
	}

	bs, err := format.Source(tmp.Bytes())
	if err != nil {
		logger.Fatalf("_fatal||reason=%+v", err)
	}

	var buf bytes.Buffer
	if _, err := buf.Write(bs); err != nil {
		logger.Fatalf("_fatal||reason=%+v", err)
	}
	return &buf
}
